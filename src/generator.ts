import {promises as fs} from 'fs';
import path from 'path';

import type {ApiMethod, TypeDeclaration, TypesMap} from './types';
import {ParameterPlace} from './types';
import {capitalize} from './utils';
import {Converter} from './Converter';

type Data = {
  apiMethods: ApiMethod[];
  types: Map<string, TypeDeclaration>;
  namespace?: string;
};

function getApiHeader({namespace, importTypes}: {namespace?: string; importTypes: string}) {
  return `/**
 * THIS FILE WAS GENERATED BY \`openapi-api-generator\` API GENERATOR
 */

/* eslint-disable @typescript-eslint/no-explicit-any,lines-between-class-members */

import type {${
    namespace
      ? ` ${namespace} `
      : `
  ${importTypes}
`
  }} from './types';

export type Method = 'GET' | 'POST' | 'PUT' | 'PATCH';

export type QueryParams = Record<string, string | number | undefined>;

export type Headers = Record<string, string>;

export type MiddlewareParams = {
  method: Method;
  route: string;
  query?: QueryParams;
  body?: any;
  headers?: Headers;
};

export type Middleware = (params: MiddlewareParams) => Promise<any>;

function interpolateParams(url: string, params: QueryParams) {
  let updatedUrl = url;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const match = updatedUrl.match(/{([A-Za-z_][A-Za-z0-9_]*)}/);

    if (!match) {
      break;
    }

    const value = params[match[1]] ?? '';

    updatedUrl = \`\${updatedUrl.substr(0, match.index)}\${value}\${updatedUrl.substr((match.index || 0) + match[0].length)}\` 
  }

  return updatedUrl;
}

class ApiGroup {
  public readonly method: Method;

  private readonly middleware: Middleware;

  public constructor(method: Method, middleware: Middleware) {
    this.method = method;
    this.middleware = middleware;
  }

  protected callApi(route: string, query?: QueryParams, body?: any, headers?: Headers): Promise<any> {
    return this.middleware({
      method: this.method,
      route,
      query,
      body,
      headers,
    });
  }
}
`;
}

const apiServiceCode = `
export class ApiService {
  public readonly get: ApiGroupGet;
  public readonly post: ApiGroupPost;
  public readonly put: ApiGroupPut;
  public readonly patch: ApiGroupPatch;

  public constructor(middleware: Middleware) {
    this.get = new ApiGroupGet(middleware);
    this.post = new ApiGroupPost(middleware);
    this.put = new ApiGroupPut(middleware);
    this.patch = new ApiGroupPatch(middleware);
  }
}
`;

function sortTypes(types: Map<string, TypeDeclaration>): TypeDeclaration[] {
  return [...types.values()].sort((info1, info2) => info1.name.localeCompare(info2.name));
}

async function processTypes(types: TypesMap, outFile: string, namespace?: string) {
  const converter = new Converter({types});

  const typeDefinitions = sortTypes(types).map((info) => {
    return `export type ${info.name} = ${converter.toTs(info.type)};`;
  });

  await fs.writeFile(
    outFile,
    `/**
 * THIS FILE WAS GENERATED BY \`openapi-api-generator\` API GENERATOR
 */
${
  namespace
    ? `
/* eslint-disable @typescript-eslint/no-namespace */

export namespace ${namespace} {
`
    : ''
}
${typeDefinitions.join('\n\n')}
${namespace ? '}' : ''}`,
  );
}

function formatMethod(
  converter: Converter,
  {routePath, params: {parameters, flatTypes}, resultType}: ApiMethod,
): string {
  const inPathParams = parameters.filter((param) => param.place == ParameterPlace.IN_PATH).map((param) => param.name);
  const inQueryParams = parameters.filter((param) => param.place == ParameterPlace.QUERY).map((param) => param.name);
  const extractParams = [...inPathParams, ...inQueryParams];

  let paramsType = parameters.length
    ? `{
    ${parameters.map((p) => `${p.name}${p.required ? '' : '?'}: ${converter.toTs(p.type, 2)}`).join(';\n    ')};
  }`
    : '';

  if (flatTypes.length) {
    paramsType += `${paramsType ? ' & ' : ''}${flatTypes.map((type) => converter.toTs(type)).join(' & ')}`;
  }

  let bodyCode = '';
  let queryParams = 'undefined';
  let routeCode = `'${routePath}'`;

  if (flatTypes.length > 0 || parameters.length - inPathParams.length - inQueryParams.length > 0) {
    bodyCode = 'body';
  }

  let paramsCode: string;

  if (extractParams.length) {
    paramsCode = `{ ${extractParams.join(', ')}${bodyCode ? `, ...${bodyCode}` : ''} }`;

    if (inPathParams) {
      routeCode = `interpolateParams('${routePath}', { ${inPathParams.join(', ')} })`;
    }

    if (inQueryParams.length) {
      queryParams = `{ ${inQueryParams.join(', ')} }`;
    }
  } else {
    paramsCode = `${bodyCode}`;
  }

  return `public '${routePath}' = async (${
    paramsCode ? `${paramsCode}: ${paramsType}` : '_?: void'
  }, headers?: Headers): Promise<${converter.toTs(resultType, 1)}> => {
    return this.callApi(${routeCode}, ${queryParams}, ${bodyCode ? bodyCode : 'undefined'}, headers);
  }`;
}

async function processApi(types: TypesMap, apiMethods: ApiMethod[], outFile: string, namespace?: string) {
  const methodGrouped: Record<string, ApiMethod[]> = {
    get: [],
    post: [],
    put: [],
    patch: [],
  };

  const converter = new Converter({types, namespace});

  for (const apiMethod of apiMethods) {
    methodGrouped[apiMethod.method.toLowerCase()].push(apiMethod);
  }

  const methodsPart = Object.entries(methodGrouped)
    .map(([methodName, list]) => {
      const methods = list.map((m) => formatMethod(converter, m));

      return `class ApiGroup${capitalize(methodName)} extends ApiGroup {
  public constructor(middleware: Middleware) {
    super('${methodName.toUpperCase()}', middleware);
  }${
    methods.length
      ? `
  ${methods.join('\n\n  ')}`
      : ''
  }
}\n`;
    })
    .join('\n');

  const filteredTypes = sortTypes(types)
    .filter((type) => converter.usedTypes.has(type.name))
    .map((type) => type.name);

  const head = getApiHeader({namespace, importTypes: filteredTypes.length ? `${filteredTypes.join(',\n  ')},` : ''});

  const apiCode = `${head}
${methodsPart}${apiServiceCode}`;

  await fs.writeFile(outFile, apiCode);
}

async function processIndex(outFile: string) {
  await fs.writeFile(
    outFile,
    `export * from './types';
export * from './api';
`,
  );
}

export async function generate({types, apiMethods, namespace}: Data, outDir: string) {
  const typesFileName = path.join(outDir, 'types.ts');
  const apiFileName = path.join(outDir, 'api.ts');
  const indexFileName = path.join(outDir, 'index.ts');

  await processTypes(types, typesFileName, namespace);
  await processApi(types, apiMethods, apiFileName, namespace);
  await processIndex(indexFileName);

  console.info(`Success (files have been generated):
  * ${path.relative(process.cwd(), typesFileName)}
  * ${path.relative(process.cwd(), apiFileName)}
  * ${path.relative(process.cwd(), indexFileName)}`);
}
