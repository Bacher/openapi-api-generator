import {promises as fs} from 'fs';
import path from 'path';

import type {ApiMethod, TypeDeclaration, TypesMap} from './types';
import {ParameterPlace} from './types';
import {capitalize} from './utils';
import {Converter} from './Converter';

type Data = {
  apiMethods: ApiMethod[];
  types: Map<string, TypeDeclaration>;
  namespace?: string;
  useEnums?: boolean;
};

function getApiHeader({namespace, importTypes}: {namespace?: string; importTypes: string}) {
  return `/**
 * THIS FILE WAS GENERATED BY \`openapi-api-generator\` API GENERATOR
 */

/* eslint-disable @typescript-eslint/no-explicit-any,lines-between-class-members */

import type {${
    namespace
      ? ` ${namespace} `
      : `
  ${importTypes}
`
  }} from './types';

export type Method = 'GET' | 'POST' | 'PUT' | 'PATCH';

export type QueryParams = Record<string, string | number | undefined>;

export type MiddlewareParams = {
  method: Method;
  route: string;
  query?: QueryParams;
  body?: any;
  headers?: Headers;
};

export type Middleware<Meta> = (params: MiddlewareParams, meta: Meta) => Promise<any>;

function interpolateParams(url: string, params: QueryParams) {
  let updatedUrl = url;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const match = updatedUrl.match(/{([A-Za-z_][A-Za-z0-9_]*)}/);

    if (!match) {
      break;
    }

    const value = params[match[1]] ?? '';

    updatedUrl = \`\${updatedUrl.substr(0, match.index)}\${value}\${updatedUrl.substr((match.index || 0) + match[0].length)}\` 
  }

  return updatedUrl;
}

class ApiGroup<Meta> {
  public readonly method: Method;

  private readonly middleware: Middleware<Meta>;

  public constructor(method: Method, middleware: Middleware<Meta>) {
    this.method = method;
    this.middleware = middleware;
  }

  protected callApi(route: string, {
      query,
      body,
      headers,
      meta,
    }: {
      query?: QueryParams;
      body?: any;
      headers?: Headers;
      meta: Meta;
    }): Promise<any> {
    return this.middleware({
      method: this.method,
      route,
      query,
      body,
      headers,
    }, meta);
  }
}
`;
}

const apiServiceCode = `
export class ApiService<Meta = never> {
  public readonly get: ApiGroupGet<Meta>;
  public readonly post: ApiGroupPost<Meta>;
  public readonly put: ApiGroupPut<Meta>;
  public readonly patch: ApiGroupPatch<Meta>;

  public constructor(middleware: Middleware<Meta>) {
    this.get = new ApiGroupGet<Meta>(middleware);
    this.post = new ApiGroupPost<Meta>(middleware);
    this.put = new ApiGroupPut<Meta>(middleware);
    this.patch = new ApiGroupPatch<Meta>(middleware);
  }
}
`;

async function processTypes(
  types: TypesMap,
  outFile: string,
  {namespace, useEnums}: {namespace?: string; useEnums?: boolean},
) {
  const converter = new Converter({types, useEnums});

  const typeDefinitions = converter.extractDefinitions();

  await fs.writeFile(
    outFile,
    `/**
 * THIS FILE WAS GENERATED BY \`openapi-api-generator\` API GENERATOR
 */
${
  namespace
    ? `
/* eslint-disable @typescript-eslint/no-namespace */

export namespace ${namespace} {
`
    : ''
}
${typeDefinitions.join('\n\n')}
${namespace ? '}' : ''}`,
  );
}

function formatMethod(
  converter: Converter,
  {routePath, params: {parameters, flatTypes}, resultType}: ApiMethod,
): string {
  const inPathParams = parameters.filter((param) => param.place == ParameterPlace.IN_PATH).map((param) => param.name);
  const inQueryParams = parameters.filter((param) => param.place == ParameterPlace.QUERY).map((param) => param.name);
  const extractParams = [...inPathParams, ...inQueryParams];

  let paramsType = parameters.length
    ? `{
    ${parameters.map((p) => `${p.name}${p.required ? '' : '?'}: ${converter.toTs(p.type, 2)}`).join(';\n    ')};
  }`
    : '';

  if (flatTypes.length) {
    paramsType += `${paramsType ? ' & ' : ''}${flatTypes.map((type) => converter.toTs(type)).join(' & ')}`;
  }

  let bodyCode = '';
  let queryParams = 'undefined';
  let routeCode = `'${routePath}'`;

  if (flatTypes.length > 0 || parameters.length - inPathParams.length - inQueryParams.length > 0) {
    bodyCode = 'body';
  }

  let paramsCode: string;

  if (extractParams.length) {
    paramsCode = `{ ${extractParams.join(', ')}${bodyCode ? `, ...${bodyCode}` : ''} }`;

    if (inPathParams.length) {
      routeCode = `interpolateParams('${routePath}', { ${inPathParams.join(', ')} })`;
    }

    if (inQueryParams.length) {
      queryParams = `{ ${inQueryParams.join(', ')} }`;
    }
  } else {
    paramsCode = bodyCode;
  }

  const inputArgument = `{${paramsCode ? `params: ${paramsCode}, ` : ''}headers, meta}: { ${
    paramsType ? `params: ${paramsType}, ` : ''
  }headers?: Headers, meta: Meta, }`;

  const args = [];

  if (bodyCode) {
    if (bodyCode === 'body') {
      args.push('body');
    } else {
      args.push(`body = ${bodyCode}`);
    }
  }

  if (queryParams) {
    args.push(`query: ${queryParams}`);
  }

  args.push('headers', 'meta');

  return `public '${routePath}' = async (${inputArgument}): Promise<${converter.toTs(resultType, 1)}> => {
    return this.callApi(${routeCode}, { ${args.join(', ')} });
  }`;
}

async function processApi(
  types: TypesMap,
  apiMethods: ApiMethod[],
  outFile: string,
  {namespace, useEnums}: {namespace?: string; useEnums?: boolean},
) {
  const methodGrouped: Record<string, ApiMethod[]> = {
    get: [],
    post: [],
    put: [],
    patch: [],
  };

  const converter = new Converter({types, namespace, useEnums});

  for (const apiMethod of apiMethods) {
    methodGrouped[apiMethod.method.toLowerCase()].push(apiMethod);
  }

  const methodsPart = Object.entries(methodGrouped)
    .map(([methodName, list]) => {
      const methods = list.map((m) => formatMethod(converter, m));

      return `class ApiGroup${capitalize(methodName)}<Meta> extends ApiGroup<Meta> {
  public constructor(middleware: Middleware<Meta>) {
    super('${methodName.toUpperCase()}', middleware);
  }${
    methods.length
      ? `

  ${methods.join('\n\n  ')}`
      : ''
  }
}\n`;
    })
    .join('\n');

  const filteredTypes = converter.getUsedTypeNames();
  const head = getApiHeader({namespace, importTypes: filteredTypes.length ? `${filteredTypes.join(',\n  ')},` : ''});

  const apiCode = `${head}
${methodsPart}${apiServiceCode}`;

  await fs.writeFile(outFile, apiCode);
}

async function processIndex(outFile: string) {
  await fs.writeFile(
    outFile,
    `export * from './types';
export * from './api';
`,
  );
}

export async function generate({types, apiMethods, namespace, useEnums}: Data, outDir: string) {
  const typesFileName = path.join(outDir, 'types.ts');
  const apiFileName = path.join(outDir, 'api.ts');
  const indexFileName = path.join(outDir, 'index.ts');

  await processTypes(types, typesFileName, {namespace, useEnums});
  await processApi(types, apiMethods, apiFileName, {namespace, useEnums});
  await processIndex(indexFileName);

  console.info(`Success (files have been generated):
  * ${path.relative(process.cwd(), typesFileName)}
  * ${path.relative(process.cwd(), apiFileName)}
  * ${path.relative(process.cwd(), indexFileName)}`);
}
